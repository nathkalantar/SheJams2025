# SOLUCIONES ALTERNATIVAS PARA PRESERVACIÃ“N DE COLOR

## ğŸ¯ PROBLEMA IDENTIFICADO:
El filtro de post-processing se aplica a TODA la pantalla despuÃ©s del render, ignorando el Queue de render de shaders individuales.

## ğŸ’¡ SOLUCIONES ALTERNATIVAS:

### **SOLUCIÃ“N 1: SORTING LAYERS (MÃS SIMPLE)**

#### **ConfiguraciÃ³n:**
1. **Ve a Edit â†’ Project Settings â†’ Tags and Layers**
2. **AÃ±ade un nuevo Sorting Layer**: `"ColorPreserved"`
3. **AsÃ­gnalo al NPC transformado**:
   ```csharp
   // En NPCInteraction.cs despuÃ©s de aplicar el material
   spriteRenderer.sortingLayerName = "ColorPreserved";
   spriteRenderer.sortingOrder = 100;
   ```

#### **Ventajas:**
- âœ… Muy simple de implementar
- âœ… No requiere shaders complicados
- âœ… Unity maneja el order automÃ¡ticamente

#### **Desventajas:**
- âŒ Puede que no funcione con post-processing global

---

### **SOLUCIÃ“N 2: CÃMARA SEPARADA (MÃS ROBUSTA)**

#### **Setup:**
1. **Crea una segunda cÃ¡mara** para sprites preservados
2. **Configura las cÃ¡maras**:
   ```
   Main Camera:
   - Culling Mask: Everything EXCEPT "ColorPreserved"
   - Depth: 0
   - Aplica post-processing aquÃ­
   
   Color Camera:
   - Culling Mask: SOLO "ColorPreserved" 
   - Depth: 1 (render despuÃ©s)
   - Sin post-processing
   ```

#### **CÃ³digo automÃ¡tico:**
```csharp
// En NPCInteraction.cs
void ApplyColorPreservation()
{
    // Cambiar layer del NPC
    gameObject.layer = LayerMask.NameToLayer("ColorPreserved");
    
    // Aplicar material normal (sin efectos especiales)
    spriteRenderer.material = colorPreservedMaterial;
}
```

#### **Ventajas:**
- âœ… Funciona garantizado
- âœ… SeparaciÃ³n completa del post-processing
- âœ… FÃ¡cil de configurar

#### **Desventajas:**
- âŒ Requiere configuraciÃ³n manual en escena
- âŒ Dos cÃ¡maras = mÃ¡s overhead

---

### **SOLUCIÃ“N 3: COMMAND BUFFER (MÃS AVANZADA)**

#### **Usa el script que creÃ©**: `ColorPreservationRenderer.cs`

#### **Setup:**
1. **AÃ±adir a Main Camera** (automÃ¡tico)
2. **En NPCInteraction.cs**:
   ```csharp
   // Descomentar las lÃ­neas TODO
   ColorPreservationRenderer.RegisterRenderer(spriteRenderer);
   ```

#### **Ventajas:**
- âœ… Render despuÃ©s de post-processing garantizado
- âœ… AutomÃ¡tico una vez configurado
- âœ… Escalable a mÃºltiples NPCs

#### **Desventajas:**
- âŒ MÃ¡s complejo de debugear
- âŒ Requiere conocimiento de Command Buffers

---

### **SOLUCIÃ“N 4: UI CANVAS (MÃS HACK-Y)**

#### **Concepto:**
Convertir el sprite a un **Image** en un Canvas con **Overlay** mode.

#### **Setup:**
```csharp
void ApplyColorPreservation()
{
    // Crear Canvas overlay
    GameObject canvasGO = new GameObject("ColorPreservedCanvas");
    Canvas canvas = canvasGO.AddComponent<Canvas>();
    canvas.renderMode = RenderMode.ScreenSpaceOverlay;
    canvas.sortingOrder = 1000;
    
    // Convertir sprite a UI Image
    GameObject imageGO = new GameObject("ColorPreservedSprite");
    imageGO.transform.SetParent(canvasGO.transform);
    
    Image image = imageGO.AddComponent<Image>();
    image.sprite = spriteRenderer.sprite;
    
    // Posicionar en mundo
    RectTransform rect = imageGO.GetComponent<RectTransform>();
    Vector3 screenPos = Camera.main.WorldToScreenPoint(transform.position);
    rect.position = screenPos;
}
```

#### **Ventajas:**
- âœ… Render garantizado despuÃ©s de todo
- âœ… No requiere configuraciÃ³n de cÃ¡maras

#### **Desventajas:**
- âŒ Hack-y y frÃ¡gil
- âŒ Problemas de posicionamiento
- âŒ No es "real" 3D

---

## ğŸ† RECOMENDACIÃ“N:

### **Para testing rÃ¡pido**: Usar SOLUCIÃ“N 1 (Sorting Layers)
### **Para producciÃ³n**: Usar SOLUCIÃ“N 2 (CÃ¡mara Separada)

## ğŸ§ª TESTING RÃPIDO - SOLUCIÃ“N 1:

1. **AÃ±ade Sorting Layer** `"ColorPreserved"`
2. **En NPCInteraction.cs**, aÃ±ade esto despuÃ©s de aplicar el material:
   ```csharp
   spriteRenderer.sortingLayerName = "ColorPreserved";
   spriteRenderer.sortingOrder = 100;
   ```
3. **Prueba** - deberÃ­a renderizarse encima de todo

Si eso no funciona, entonces el problema es definitivamente el post-processing global y necesitamos la SOLUCIÃ“N 2.

## ğŸ¯ NEXT STEPS:

1. Â¿Probar Sorting Layers primero?
2. Â¿O ir directo a la soluciÃ³n de cÃ¡mara separada?
3. Â¿Necesitas ayuda configurando cualquiera de estas?